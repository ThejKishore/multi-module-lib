## Multi-module Spring Boot runtime with jlink minimal JRE

# -----------------------------
# Stage 1: Obtain dependency information from the host-built JAR
# -----------------------------
FROM ${BUILD_BASE_IMAGE} AS jre-builder-deps
WORKDIR /work

# Accept path to host-built jar (relative to build context). Default matches Gradle bootJar output
ARG APP_JAR=build/libs/*boot.jar

# Copy the executable Spring Boot jar from the build context
COPY ${APP_JAR} /work/app.jar

# Extract module dependencies required for building a custom JRE
RUN jdeps \
      --multi-release 21 \
      --print-module-deps \
      --ignore-missing-deps \
      /work/app.jar > /work/deps.txt

# -----------------------------
# Stage 2: Build the custom JRE with jlink
# -----------------------------
FROM ${BUILD_BASE_IMAGE} AS jre-builder
WORKDIR /work

# Bring in app jar and computed deps
COPY --from=jre-builder-deps /work/app.jar /work/app.jar
COPY --from=jre-builder-deps /work/deps.txt /work/deps.txt

# Include minimal extra modules known to be required by Spring Boot + Tomcat
# - jdk.crypto.ec: EC crypto for TLS
# - java.desktop: java.beans.PropertyEditorSupport used by Boot binder
# - java.management: JMX types used by Tomcat
# - java.logging: java.util.logging required by Tomcat JULI
# - java.naming: javax.naming.* used by Tomcat JNDI
# - java.security.jgss: org.ietf.jgss.* used by Tomcat default realm / GSS-API
# - java.instrument: java.lang.instrument.* needed by Tomcat/Boot at startup on JREs without tools
# - java.sql: JDBC APIs used by Spring/JDBC/H2
# - jdk.unsupported: sun.misc.Unsafe used transitively by Objenesis/CGLIB
RUN echo "jdk.crypto.ec,java.desktop,java.management,java.logging,java.naming,java.security.jgss,java.instrument,java.sql,jdk.unsupported" > /work/extras.txt \
 && MODS=$(cat /work/deps.txt) \
 && EXTRAS=$(tr -d '\n' < /work/extras.txt) \
 && jlink \
        --add-modules ${MODS},${EXTRAS} \
        --no-header-files \
        --no-man-pages \
        --strip-debug \
        --compress=2 \
        --output /jre

# -----------------------------
# Stage 3: Minimal runtime image (distroless, non-root)
# -----------------------------
FROM ${RUNTIME_BASE_IMAGE} AS runtime-base
ENV TZ=UTC
WORKDIR /app

# Copy custom JRE and application artifact
COPY --from=jre-builder /jre /opt/jre
ENV PATH=/opt/jre/bin:$PATH

# Accept path to host-built jar again for the final image copy
ARG APP_JAR=build/libs/*.jar
COPY ${APP_JAR} /app/app.jar

EXPOSE 8080
USER nonroot

# Keep entrypoint simple; container memory limits are respected by JDK 21
ENTRYPOINT ["java","-XX:MaxRAMPercentage=75.0","-jar","/app/app.jar"]
